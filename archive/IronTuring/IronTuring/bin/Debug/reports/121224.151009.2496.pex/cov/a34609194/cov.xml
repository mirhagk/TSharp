<documents created="2012-12-24 20:11:20Z"><document src="C:\skydrive\programming\IronTuring\IronTuring\CodeGenOld.cs" renderPrefix="s0"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Irony.Parsing;
using System.IO;

using System.Reflection.Emit;
using System.Reflection;

namespace IronTuring
{
public sealed class CodeGenOld
{
    /// <summary>
    /// A function definition. Stores all of the required information to generate and call the functions
    /// </summary>
    class FunctionDefinition
    {
        public class Argument
        {
            public string argName;
            public Type argType;
        }
        public MethodBuilder methodDefinition;
        public List<Argument> arguments;
    }
    /// <summary>
    /// The point of this class is to gather together the local variables available to a scope, as well as the arguments it can access.
    /// </summary>
    class SymbolTable
    {
        public Dictionary<string, LocalBuilder> locals = new Dictionary<string, LocalBuilder>();
        public List<Tuple<string, Type>> parameters = new List<Tuple<string, Type>>();

        public void AddLocal(string ident, LocalBuilder localBuilder)
        {
            locals.Add(ident, localBuilder);
        }
        public void AddParameter(string ident, Type type)
        {
            parameters.Add(new Tuple<string, Type>(ident, type));
        }
        public void PushVar(string ident, ref ILGenerator il)
        {
            if (!locals.ContainsKey(ident))
            {
                for (int i = 0; i < parameters.Count; i++)
                {
                    if (parameters[i].Item1 == ident)
                    {
                        il.Emit(OpCodes.Ldarg, i);
                        return;
                    }
                }
                throw new System.Exception("undeclared variable '" + ident + "'");
            }
            il.Emit(OpCodes.Ldloc, locals[ident]);
        }
        public Type TypeOfVar(string ident)
        {
            if (locals.ContainsKey(ident))
            {
                LocalBuilder locb = locals[ident];
                return locb.LocalType;
            }   
            for (int i = 0; i < parameters.Count; i++)
            {
                if (parameters[i].Item1 == ident)
                {
                    return parameters[i].Item2;
                }
            }
            throw new System.Exception("undeclared variable '" + ident + "'");
        }
        public void Store(string name, System.Type type, ILGenerator il)
        {
            if (locals.ContainsKey(name))
            {
                LocalBuilder locb = locals[name];

                if (locb.LocalType == type)
                {
                    il.Emit(OpCodes.Stloc, locals[name]);
                }
                else
                {
                    throw new System.Exception("'" + name + "' is of type " + locb.LocalType.Name + " but attempted to store value of type " + type.Name);
                }
                return;
            }
            for (int i = 0; i < parameters.Count; i++)
            {
                if (parameters[i].Item1 == name)
                {
                    il.Emit(OpCodes.Starg, i);
                    return;
                }
            }
            throw new System.Exception("undeclared variable '" + name + "'");
        }
    }
    ]]></source>
</chunk>
<method name=".ctor" namespace="IronTuring" type="IronTuring.CodeGenOld" typeName="CodeGenOld" token="6000001" module="IronTuring.exe"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="6" value="1"/>
<hit index="7" value="1"/>
<hit index="8" value="1"/>
<hit index="9" value="1"/>
<hit index="10" value="1"/>
<hit index="11" value="1"/>
<hit index="17" value="1"/>
<hit index="18" value="1"/>
<hit index="19" value="1"/>
<hit index="162" value="1"/>
<hit index="167" value="1"/>
</hits>
<tags><tag offset="0014">call to uninstrumented method Path.GetFileName(String)</tag>
<tag offset="0035">call to uninstrumented method Path.GetFileNameWithoutExtension(String)</tag>
</tags>
<coverage domain="usercodeundertest" unit="block" covered="7" total="47" coveredRatio="0.14893617021276595"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[Dictionary<string, FunctionDefinition> functionTable = new Dictionary<string, FunctionDefinition>();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    TypeBuilder mainProgram;

    ]]></source>
</chunk>
<chunk hits="2" offset="000b" domain="usercodeundertest"><source><![CDATA[public CodeGenOld(ParseTreeNode stmt, string moduleName)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    ]]></source>
</chunk>
<chunk hits="1" offset="0012" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0013" domain="usercodeundertest" tag="true"><tooltip><![CDATA[call to uninstrumented method Path.GetFileName(String)]]></tooltip>
<source><![CDATA[if (Path.GetFileName(moduleName) != moduleName)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0028" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0029" domain="usercodeundertest"><source><![CDATA[throw new System.Exception("can only output into current directory!");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        }

        ]]></source>
</chunk>
<chunk hits="1" offset="0034" domain="usercodeundertest" tag="true"><tooltip><![CDATA[call to uninstrumented method Path.GetFileNameWithoutExtension(String)]]></tooltip>
<source><![CDATA[AssemblyName name = new AssemblyName(Path.GetFileNameWithoutExtension(moduleName));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0040" domain="usercodeundertest"><source><![CDATA[AssemblyBuilder asmb = System.AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Save);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="004d" domain="usercodeundertest"><source><![CDATA[ModuleBuilder modb = asmb.DefineDynamicModule(moduleName);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0055" domain="usercodeundertest"><source><![CDATA[mainProgram = modb.DefineType("Program");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0066" domain="usercodeundertest"><source><![CDATA[var mainArgs = new List<Tuple<string,Type>>();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="006c" domain="usercodeundertest"><source><![CDATA[var mainProgramDef = new FunctionDefinition()
        {
            methodDefinition=mainProgram.DefineMethod("Main", MethodAttributes.Static, typeof(void), System.Type.EmptyTypes),
            arguments=new List<FunctionDefinition.Argument>()
        };]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="00ab" domain="usercodeundertest"><source><![CDATA[functionTable.Add("Main",mainProgramDef);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="00be" domain="usercodeundertest"><source><![CDATA[SymbolTable symbolTable = new SymbolTable();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // CodeGenerator
        ]]></source>
</chunk>
<chunk hits="0" offset="00c5" domain="usercodeundertest"><source><![CDATA[var il = functionTable["Main"].methodDefinition.GetILGenerator();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        // Go Compile!
        ]]></source>
</chunk>
<chunk hits="0" offset="00e1" domain="usercodeundertest"><source><![CDATA[this.GenStmt(stmt, il, symbolTable);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        ]]></source>
</chunk>
<chunk hits="0" offset="00ed" domain="usercodeundertest"><source><![CDATA[il.Emit(OpCodes.Ldstr, "Press any key to exit the program...");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="00ff" domain="usercodeundertest"><source><![CDATA[il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("WriteLine", new Type[] { typeof(string) }));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0138" domain="usercodeundertest"><source><![CDATA[il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("ReadKey", new Type[] { }));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        ]]></source>
</chunk>
<chunk hits="0" offset="015f" domain="usercodeundertest"><source><![CDATA[il.Emit(OpCodes.Ret);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="016c" domain="usercodeundertest"><source><![CDATA[mainProgram.CreateType();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="0178" domain="usercodeundertest"><source><![CDATA[modb.CreateGlobalFunctions();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="017f" domain="usercodeundertest"><source><![CDATA[asmb.SetEntryPoint(functionTable["Main"].methodDefinition);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="019b" domain="usercodeundertest"><source><![CDATA[asmb.Save(moduleName);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="01a3" domain="usercodeundertest"><source><![CDATA[foreach]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ (]]></source>
</chunk>
<chunk hits="0" offset="01b4" domain="usercodeundertest"><source><![CDATA[var symbol]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="01d8" domain="usercodeundertest"><source><![CDATA[in]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="01a4" domain="usercodeundertest"><source><![CDATA[symbolTable.locals]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
        ]]></source>
</chunk>
<chunk hits="0" offset="01bd" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="01be" domain="usercodeundertest"><source><![CDATA[Console.WriteLine("{0}: {1}", symbol.Key, symbol.Value);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="01d7" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="01f7" domain="usercodeundertest"><source><![CDATA[symbolTable = null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="0" offset="01fa" domain="usercodeundertest"><source><![CDATA[il = null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
    ]]></source>
</chunk>
<chunk hits="0" offset="01fd" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

    private void GenStmt(ParseTreeNode stmt, ILGenerator il, SymbolTable symbolTable)
    {
        if (stmt.Term.Name == "program")
        {
            if (stmt.ChildNodes.Count > 0)
            {
                this.GenStmt(stmt.ChildNodes[0].ChildNodes[0], il, symbolTable);
                this.GenStmt(stmt.ChildNodes[1], il, symbolTable);
            }
        }
        else if (stmt.Term.Name == "variableDeclaration")
        {
            Type localType;
            // declare a local
            if (stmt.ChildNodes[2].Term.Name == "typeSpecifier")
            {
                localType = this.TypeOfTypeDeclaration(stmt.ChildNodes[2].ChildNodes[1]);
            }
            else
            {
                localType = this.TypeOfExpr(stmt.ChildNodes[2].ChildNodes[1], symbolTable);
                //symbolTable.locals[stmt.ChildNodes[1].ChildNodes[0].Token.ValueString] = il.DeclareLocal(this.TypeOfExpr(stmt.ChildNodes[2].ChildNodes[1], symbolTable));
            }
            Action<string> generateAssign = null;
            ParseTreeNode assign = stmt.ChildNodes.Where(x => x.Term.Name == "setEqual").SingleOrDefault();
            // set the initial value
            if (assign != null)
            {
                generateAssign = new Action<string>(name =>
                {
                    this.GenExpr(assign.ChildNodes[1], symbolTable.locals[name].LocalType, il, symbolTable);
                    symbolTable.Store(name, this.TypeOfExpr(assign.ChildNodes[1], symbolTable), il);
                });
            }
            var variableIden = stmt.ChildNodes[1];
            while (true)
            {
                string name = variableIden.ChildNodes[0].Token.ValueString;
                symbolTable.AddLocal(name,il.DeclareLocal(localType));
                if (generateAssign != null)
                    generateAssign(name);

                if (variableIden.ChildNodes.Count < 2)
                    break;
                variableIden = variableIden.ChildNodes[1];
            }
        }
        else if (stmt.Term.Name == "io")
        {
            if (stmt.ChildNodes[0].Token.ValueString == "put")
            {
                ParseTreeNode argItem = stmt.ChildNodes[1];
                while (true)
                {
                    this.GenExpr(argItem.ChildNodes[0], typeof(string), il, symbolTable);
                    il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("Write", new System.Type[] { typeof(string) }));
                    if (argItem.ChildNodes.Count > 1)
                        argItem = argItem.ChildNodes[1];
                    else 
                        break;
                }
                il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("WriteLine", new System.Type[] { }));
            }
        }
        else if (stmt.Term.Name == "assignment")
        {
            string ident = stmt.ChildNodes[0].Token.ValueString;
            this.GenExpr(stmt.ChildNodes[1].ChildNodes[1], this.TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), il, symbolTable);
            symbolTable.Store(ident, this.TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), il);
            //this.Store(ident, this.TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), ref il, symbolTable);
        }
        else if (stmt.Term.Name == "functionDefinition")
        {
            string functionName = stmt.ChildNodes[1].Token.ValueString;
            if (functionTable.ContainsKey(functionName))
            {
                throw new Exception(functionName + " has already been defined");
            }
            var parameterList = new List<FunctionDefinition.Argument>();
            List<Type> types = new List<Type>();
            SymbolTable localSymbols = new SymbolTable();
            if (stmt.ChildNodes[2].ChildNodes.Count > 0)
            {
                var currParam = stmt.ChildNodes[2].ChildNodes[0];
                while (true)
                {
                    var parameterType = TypeOfExpr(currParam.ChildNodes[0].ChildNodes[1].ChildNodes[1], symbolTable);
                    var paramIdentifier = currParam.ChildNodes[0].ChildNodes[0];
                    while (true)
                    {
                        var parameterName = paramIdentifier.ChildNodes[0].Token.ValueString;
                        parameterList.Add(new FunctionDefinition.Argument() { argName = parameterName, argType = parameterType });
                        localSymbols.AddParameter(parameterName, parameterType);
                        types.Add(parameterType);
                        if (paramIdentifier.ChildNodes.Count == 1)
                            break;
                        paramIdentifier = paramIdentifier.ChildNodes[1];
                    }
                    
                    if (currParam.ChildNodes.Count == 1)
                        break;
                    currParam = currParam.ChildNodes[1];
                }
            }
            var methodDeclaration = mainProgram.DefineMethod(functionName, MethodAttributes.Static, TypeOfExpr(stmt.ChildNodes[3].ChildNodes[1], symbolTable), types.ToArray());
            var ilMeth = methodDeclaration.GetILGenerator();
            //if (stmt.ChildNodes[2].ChildNodes.Count > 0)
            //{
            //    var currParam = stmt.ChildNodes[2].ChildNodes[0];
            //    while (true)
            //    {
            //        //localSymbols.parameters.Add(new Tuple<string, Type>(currParam.ChildNodes[0].ChildNodes[0].Token.ValueString, TypeOfExpr(currParam.ChildNodes[0].ChildNodes[1].ChildNodes[1], symbolTable)));
            //        if (currParam.ChildNodes.Count == 1)
            //            break;
            //        currParam = currParam.ChildNodes[1];
            //    }
            //}
            GenStmt(stmt.ChildNodes[4], ilMeth, localSymbols);
            ilMeth.Emit(OpCodes.Ret);
            var methodDec = new FunctionDefinition()
            {
                methodDefinition = methodDeclaration,
                arguments = parameterList
            };
            functionTable.Add(functionName, methodDec);

        }
        else if (stmt.Term.Name == "result")
        {
            GenExpr(stmt.ChildNodes[1], TypeOfExpr(stmt.ChildNodes[1], symbolTable), il, symbolTable);
            var result = il.DeclareLocal(TypeOfExpr(stmt.ChildNodes[1], symbolTable));
            il.Emit(OpCodes.Stloc, result);
            il.Emit(OpCodes.Ldloc, result);
            il.Emit(OpCodes.Ret, result);
        }
        /*
        else if (stmt is ReadInt)
        {
            this.il.Emit(Emit.OpCodes.Call, typeof(System.Console).GetMethod("ReadLine", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new System.Type[] { }, null));
            this.il.Emit(Emit.OpCodes.Call, typeof(int).GetMethod("Parse", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, null, new System.Type[] { typeof(string) }, null));
            this.Store(((ReadInt)stmt).Ident, typeof(int));
        }
        else if (stmt is ForLoop)
        {
            // example: 
            // for x = 0 to 100 do
            //   print "hello";
            // end;

            // x = 0
            ForLoop forLoop = (ForLoop)stmt;
            Assign assign = new Assign();
            assign.Ident = forLoop.Ident;
            assign.Expr = forLoop.From;
            this.GenStmt(assign);
            // jump to the test
            Emit.Label test = this.il.DefineLabel();
            this.il.Emit(Emit.OpCodes.Br, test);

            // statements in the body of the for loop
            Emit.Label body = this.il.DefineLabel();
            this.il.MarkLabel(body);
            this.GenStmt(forLoop.Body);

            // to (increment the value of x)
            this.il.Emit(Emit.OpCodes.Ldloc, this.symbolTable[forLoop.Ident]);
            this.il.Emit(Emit.OpCodes.Ldc_I4, 1);
            this.il.Emit(Emit.OpCodes.Add);
            this.Store(forLoop.Ident, typeof(int));

            // **test** does x equal 100? (do the test)
            this.il.MarkLabel(test);
            this.il.Emit(Emit.OpCodes.Ldloc, this.symbolTable[forLoop.Ident]);
            this.GenExpr(forLoop.To, typeof(int));
            this.il.Emit(Emit.OpCodes.Blt, body);
        }*/
        else
        {
            throw new System.Exception("don't know how to gen a " + stmt.Term.Name);
        }



    }

    /*private void Store(string name, System.Type type, ref ILGenerator il, SymbolTable symbolTable)
    {
        if (symbolTable.locals.ContainsKey(name))
        {
            LocalBuilder locb = symbolTable.locals[name];

            if (locb.LocalType == type)
            {
                il.Emit(OpCodes.Stloc, symbolTable.locals[name]);
            }
            else
            {
                throw new System.Exception("'" + name + "' is of type " + locb.LocalType.Name + " but attempted to store value of type " + type.Name);
            }
        }
        else
        {
            throw new System.Exception("undeclared variable '" + name + "'");
        }
    }*/

    private void GenExpr(ParseTreeNode expr, System.Type expectedType, ILGenerator il, SymbolTable symbolTable)
    {
        Type deliveredType;
        if (expr.Term.Name == "stringLiteral")
        {
            deliveredType = typeof(string);
            il.Emit(OpCodes.Ldstr, expr.Token.ValueString);
        }
        else if (expr.Term.Name == "number")
        {
            if (expr.Token.Value is int)
            {
                deliveredType = typeof(int);
                il.Emit(OpCodes.Ldc_I4, (int)expr.Token.Value);
            }
            else
            {
                deliveredType = typeof(float);
                il.Emit(OpCodes.Ldc_R4, float.Parse(expr.Token.ValueString));
            }
        }
        else if (expr.Term.Name == "binExpr")
        {
            deliveredType = TypeOfExpr(expr.ChildNodes[0], symbolTable);
            GenExpr(expr.ChildNodes[0], deliveredType, il, symbolTable);
            GenExpr(expr.ChildNodes[2], deliveredType, il, symbolTable);
            switch (expr.ChildNodes[1].Term.Name)
            {
                case "+":
                    il.Emit(OpCodes.Add);
                    break;
                case "*":
                    il.Emit(OpCodes.Mul);
                    break;
                case "-":
                    il.Emit(OpCodes.Sub);
                    break;
                case "/":
                    il.Emit(OpCodes.Div);
                    break;
                case "mod":
                    il.Emit(OpCodes.Rem);
                    break;
                default:
                    throw new Exception("Unrecognized operator " + expr.ChildNodes[1].Term.Name);
            }

        }
        else if (expr.Term.Name == "identifier")
        {
            string ident = expr.Token.ValueString;
            symbolTable.PushVar(ident, ref il);
            deliveredType = this.TypeOfExpr(expr, symbolTable);
        }
        else if (expr.Term.Name == "functionCall")
        {
            deliveredType = TypeOfExpr(expr, symbolTable);

            string funcName = expr.ChildNodes[0].Token.ValueString;
            if (!this.functionTable.ContainsKey(funcName))
            {
                throw new System.Exception("undeclared function or procedure '" + funcName+ "'");
            }
            var parameters = this.functionTable[funcName].arguments;
            int currentArgument = 0;
            if (expr.ChildNodes[1].ChildNodes.Count > 0)
            {//push all the arguments onto the stack

                ParseTreeNode argItem = expr.ChildNodes[1];
                while (true)
                {
                    this.GenExpr(argItem.ChildNodes[0], parameters[currentArgument].argType, il, symbolTable);
                    if (argItem.ChildNodes.Count == 1)
                        break;
                    argItem = argItem.ChildNodes[1];
                    currentArgument++;
                }
            }
            il.Emit(OpCodes.Call, this.functionTable[funcName].methodDefinition);
        }
        else
        {
            throw new System.Exception("don't know how to generate " + expr.GetType().Name);
        }
        
        if (deliveredType != expectedType)
        {
            if (deliveredType == typeof(int) &&
                expectedType == typeof(string))
            {
                il.Emit(OpCodes.Box, typeof(int));
                il.Emit(OpCodes.Callvirt, typeof(object).GetMethod("ToString"));
            }
            else if (deliveredType==typeof(float)&&expectedType==typeof(string))
            {
                il.Emit(OpCodes.Box, typeof(float));
                il.Emit(OpCodes.Callvirt, typeof(object).GetMethod("ToString"));
            }
            else
            {
                throw new System.Exception("can't coerce a " + deliveredType.Name + " to a " + expectedType.Name);
            }
        }
    }

    private Type TypeOfExpr(ParseTreeNode expr, SymbolTable symbolTable)
    {
        if (expr.Term.Name == "stringLiteral")
        {
            return typeof(string);
        }
        if (expr.Term.Name == "number")
        {
            if (expr.Token.Value is int)
            {
                return typeof(int);
            }
            else
            {
                return typeof(float);
            }
        }
        else if (expr.Term.Name == "binExpr")
        {
            Type type1 = TypeOfExpr(expr.ChildNodes[0], symbolTable);
            Type type2 = TypeOfExpr(expr.ChildNodes[2], symbolTable);
            if (type1 == typeof(float) || type2 == typeof(float))
                return typeof(float);
            return typeof(int);
        }
        else if (expr.Term.Name == "identifier")
        {
            string ident = expr.Token.ValueString;
            return symbolTable.TypeOfVar(ident);
        }
        else if (expr.Term.Name == "functionCall")
        {
            string funcName = expr.ChildNodes[0].Token.ValueString;
            if (!this.functionTable.ContainsKey(funcName))
            {
                throw new System.Exception("undeclared function or procedure '" + funcName + "'");
            }
            return functionTable[funcName].methodDefinition.ReturnType;
        }
        else if (expr.Term.Name == "varType")
        {
            switch (expr.ChildNodes[0].Token.ValueString)
            {
                case "int":
                    return typeof(int);
                case "real":
                    return typeof(float);
                default:
                    throw new Exception("Did not recognize type: " + expr.ChildNodes[0].Token.ValueString);
            }
        }
        else
        {
            throw new System.Exception("don't know how to calculate the type of " + expr.Term.Name);
        }
    }

    private Type TypeOfTypeDeclaration(ParseTreeNode expr)
    {
        switch (expr.ChildNodes[0].Token.ValueString )
        {
            case "array":
                return TypeOfTypeDeclaration(expr.ChildNodes[3]).MakeArrayType();
                throw new NotImplementedException();
            case "int":
                return typeof(int);
            case "string":
                return typeof(string);
            case "real":
                return typeof(float);
            default:
                throw new System.Exception("don't know how to calculate the type of " + expr.ToString());
        }
    }
}
}]]></source>
</chunk>
</document>
<document src="C:\skydrive\programming\IronTuring\IronTuring\CodeGen.cs" renderPrefix="s1"><chunk hits="-1" domain="unknown"><source><![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Irony.Parsing;
using System.IO;

using System.Reflection.Emit;
using System.Reflection;

namespace IronTuring
{
    public sealed class CodeGen
    {
        TypeBuilder mainProgram;
        AssemblyBuilder asmb;

        ]]></source>
</chunk>
<method name=".ctor" namespace="IronTuring" type="IronTuring.CodeGen" typeName="CodeGen" token="600000f" module="IronTuring.exe"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="2" value="1"/>
<hit index="3" value="1"/>
<hit index="4" value="1"/>
<hit index="5" value="1"/>
<hit index="6" value="1"/>
<hit index="12" value="1"/>
<hit index="13" value="1"/>
<hit index="14" value="1"/>
<hit index="123" value="1"/>
<hit index="126" value="1"/>
</hits>
<tags><tag offset="0009">call to uninstrumented method Path.GetFileName(String)</tag>
<tag offset="002a">call to uninstrumented method Path.GetFileNameWithoutExtension(String)</tag>
</tags>
<coverage domain="usercodeundertest" unit="block" covered="6" total="38" coveredRatio="0.15789473684210525"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[public CodeGen(ParseTreeNode stmt, string moduleName)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        ]]></source>
</chunk>
<chunk hits="1" offset="0007" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0008" domain="usercodeundertest" tag="true"><tooltip><![CDATA[call to uninstrumented method Path.GetFileName(String)]]></tooltip>
<source><![CDATA[if (Path.GetFileName(moduleName) != moduleName)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="001d" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="001e" domain="usercodeundertest"><source><![CDATA[throw new System.Exception("can only output into current directory!");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }

            ]]></source>
</chunk>
<chunk hits="1" offset="0029" domain="usercodeundertest" tag="true"><tooltip><![CDATA[call to uninstrumented method Path.GetFileNameWithoutExtension(String)]]></tooltip>
<source><![CDATA[AssemblyName name = new AssemblyName(Path.GetFileNameWithoutExtension(moduleName));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            ]]></source>
</chunk>
<chunk hits="0" offset="0035" domain="usercodeundertest"><source><![CDATA[asmb = System.AppDomain.CurrentDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Save);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            ]]></source>
</chunk>
<chunk hits="0" offset="0047" domain="usercodeundertest"><source><![CDATA[ModuleBuilder modb = asmb.DefineDynamicModule(moduleName);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            //mainProgram = modb.DefineType("Program");
            
            
            //var mainArgs = new List<Tuple<string, Type>>();
            //var mainProgramDef = new FunctionDefinition
            //(
            //    mainProgram.DefineMethod("Main", MethodAttributes.Static, typeof(void), System.Type.EmptyTypes),
            //    new List<FunctionDefinition.Argument>()
            //);

            ]]></source>
</chunk>
<chunk hits="0" offset="0054" domain="usercodeundertest"><source><![CDATA[SymbolTable symbolTable = new SymbolTable(modb.DefineType("__Program"));]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            ]]></source>
</chunk>
<chunk hits="0" offset="0065" domain="usercodeundertest"><source><![CDATA[symbolTable.AddFunctionHeader("__Main", MethodAttributes.Static, null, new FunctionDefinition.Argument[]{});]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //symbolTable.functionTable.AddHeader("Main", mainProgramDef);

            ]]></source>
</chunk>
<chunk hits="0" offset="007f" domain="usercodeundertest"><source><![CDATA[stmt = PreGenerate(stmt, symbolTable);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0088" domain="usercodeundertest"><source><![CDATA[stmt = ImportList(stmt, symbolTable);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            // CodeGenerator
            ]]></source>
</chunk>
<chunk hits="0" offset="0091" domain="usercodeundertest"><source><![CDATA[var il = symbolTable.functionTable["__Main"].GetILGenerator();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            // Go Compile!
            ]]></source>
</chunk>
<chunk hits="0" offset="00a7" domain="usercodeundertest"><source><![CDATA[this.GenStmt(stmt, il, symbolTable);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

            //il.Emit(OpCodes.Ldstr, "Press any key to exit the program...");
            //il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("WriteLine", new Type[] { typeof(string) }));
            //il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("ReadKey", new Type[] { }));

            ]]></source>
</chunk>
<chunk hits="0" offset="00bb" domain="usercodeundertest"><source><![CDATA[il.Emit(OpCodes.Ret);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00c7" domain="usercodeundertest"><source><![CDATA[mainProgram.CreateType();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00d3" domain="usercodeundertest"><source><![CDATA[modb.CreateGlobalFunctions();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00da" domain="usercodeundertest"><source><![CDATA[asmb.SetEntryPoint(symbolTable.functionTable["__Main"].methodDefinition);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            
            ]]></source>
</chunk>
<chunk hits="0" offset="00fb" domain="usercodeundertest"><source><![CDATA[asmb.Save(moduleName);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0108" domain="usercodeundertest"><source><![CDATA[foreach]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ (]]></source>
</chunk>
<chunk hits="0" offset="0118" domain="usercodeundertest"><source><![CDATA[var symbol]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="013c" domain="usercodeundertest"><source><![CDATA[in]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[ ]]></source>
</chunk>
<chunk hits="0" offset="0109" domain="usercodeundertest"><source><![CDATA[symbolTable.locals]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[)
            ]]></source>
</chunk>
<chunk hits="0" offset="0121" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0122" domain="usercodeundertest"><source><![CDATA[Console.WriteLine("{0}: {1}", symbol.Key, symbol.Value);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="013b" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="015b" domain="usercodeundertest"><source><![CDATA[symbolTable = null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="015d" domain="usercodeundertest"><source><![CDATA[il = null;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        ]]></source>
</chunk>
<chunk hits="0" offset="015f" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[

        static ParseTreeNode ImportList(ParseTreeNode stmt, SymbolTable symbolTable)
        {
            ParseTreeNode result = stmt.ChildNodes[1];
            foreach (ParseTreeNode item in stmt.ChildNodes[0].ChildNodes)
            {
                if (item.Term.Name == "import")
                {
                    symbolTable.functionTable.AddLibrary(GetIdentifier(item.ChildNodes[0]), item.ChildNodes.Count > 1 ? item.ChildNodes[1].Token.ValueString : null);
                }
                else
                    result.ChildNodes.Add(item);
            }
            return result;
        }

        static string GetIdentifier(ParseTreeNode stmt)
        {
            if (stmt.Term.Name == "identifier")
                return stmt.Token.ValueString;
            else if (stmt.Term.Name == "functionCall")
            {
                return stmt.ChildNodes[0].Token.ValueString;
            }
            else if (stmt.Term.Name == "memberCall")
            {
                return stmt.ChildNodes[0].Token.ValueString + "." + GetIdentifier(stmt.ChildNodes[1]);
            }
            throw new Exception("Don't know how to generate indentifier for " + stmt.Term.Name);
        }

        static ParseTreeNodeList GetArgs(ParseTreeNode stmt)
        {
            if (stmt.Term.Name == "functionCall")
            {
                return stmt.ChildNodes[1].ChildNodes;
            }
            else if (stmt.Term.Name == "memberCall")
            {
                return GetArgs(stmt.ChildNodes[1]);
            }
            throw new Exception("Can't get arguments for " + stmt.Term.Name);
        }

        /// <summary>
        /// The pregeneration step. During this stage the compiler replaces all include statements with the appropriate code. It also builds the function table (without definitions)
        /// so that functions can be referenced before they are declared in the code
        /// </summary>
        /// <param name="stmt"></param>
        /// <param name="il"></param>
        /// <param name="symbolTable"></param>
        /// <returns></returns>
        static ParseTreeNode PreGenerate(ParseTreeNode stmt, SymbolTable symbolTable)
        {
            if (stmt.Term.Name == "program")
            {
                if (stmt.ChildNodes.Count > 0)
                {
                    stmt.ChildNodes[0].ChildNodes[0] = PreGenerate(stmt.ChildNodes[0].ChildNodes[0], symbolTable);
                    stmt.ChildNodes[1] = PreGenerate(stmt.ChildNodes[1], symbolTable);
                    return stmt;
                }
            }
            else if (stmt.Term.Name == "unit")
            {
                stmt.ChildNodes[0] = PreGenerate(stmt.ChildNodes[0], symbolTable);
                stmt.ChildNodes[1] = PreGenerate(stmt.ChildNodes[1], symbolTable);
            }
            else if (stmt.Term.Name == "importSection")
            {
                for (int i = 0; i < stmt.ChildNodes.Count; i++)
                {
                    stmt.ChildNodes[i] = PreGenerate(stmt.ChildNodes[i], symbolTable);
                }
            }
            else if (stmt.Term.Name == "include")
            {
                string filename = stmt.Token.ValueString;
                if (!File.Exists(filename))
                {
                    Console.WriteLine("File does not exist");
                    Console.ReadKey();
                    return null;
                }
                var rootNode = Program.getRoot(System.IO.File.ReadAllText(filename), new TSharpCompiler.TuringGrammarBroken());
                if (rootNode == null)
                {
                    Console.WriteLine("Parsing failed");
                    Console.ReadKey();
                    return null;
                }
                return PreGenerate(rootNode, symbolTable);
            }
            else if (stmt.Term.Name == "functionDefinition")
            {
                string functionName = stmt.ChildNodes[0].ChildNodes[1].Token.ValueString;
                if (symbolTable.functionTable.ContainsKey(functionName))
                {
                    throw new Exception(functionName + " has already been defined");
                }
                var parameterList = new List<FunctionDefinition.Argument>();
                if (stmt.ChildNodes[0].ChildNodes[2].ChildNodes.Count > 0)
                {
                    var currParam = stmt.ChildNodes[0].ChildNodes[2].ChildNodes[0];
                    while (true)
                    {
                        var parameterType = TypeOfExpr(currParam.ChildNodes[0].ChildNodes[1].ChildNodes[0], symbolTable);
                        var paramIdentifier = currParam.ChildNodes[0].ChildNodes[0];
                        while (true)
                        {
                            var parameterName = paramIdentifier.ChildNodes[0].Token.ValueString;
                            parameterList.Add(new FunctionDefinition.Argument() { argName = parameterName, argType = parameterType });
                            if (paramIdentifier.ChildNodes.Count == 1)
                                break;
                            paramIdentifier = paramIdentifier.ChildNodes[1];
                        }
                        if (currParam.ChildNodes.Count == 1)
                            break;
                        currParam = currParam.ChildNodes[1];
                    }
                }
                Type type = null;
                if (stmt.ChildNodes[0].ChildNodes.Count > 3)//if there's a 4th childnode then it's the type specifier
                    type = TypeOfExpr(stmt.ChildNodes[0].ChildNodes[3].ChildNodes[0], symbolTable);

                symbolTable.AddFunctionHeader(functionName, MethodAttributes.Static, type, parameterList.ToArray());
                //MethodBuilder methodDeclaration;
                //if (stmt.ChildNodes[0].ChildNodes.Count > 3)//if there's a 4th childnode then it's the type specifier
                //    methodDeclaration = mainProgram.DefineMethod(functionName, MethodAttributes.Static, TypeOfExpr(stmt.ChildNodes[0].ChildNodes[3].ChildNodes[0], symbolTable), parameterList.Select(x => x.argType).ToArray());
                //else
                //    methodDeclaration = mainProgram.DefineMethod(functionName, MethodAttributes.Static, null, parameterList.Select(x => x.argType).ToArray());

                //var methodDec = new FunctionDefinition
                //(
                //    methodDeclaration,
                //    parameterList
                //);
                //symbolTable.functionTable.AddHeader(functionName, methodDec);
            }
            else if (stmt.Term.Name == "type")
            {
                
                if (stmt.ChildNodes[1].ChildNodes[0].ChildNodes[0].Term.Name == "recordList")
                {
                    symbolTable.CreateNewType(stmt.ChildNodes[1].ChildNodes[0].ChildNodes[0], stmt.ChildNodes[0].Token.ValueString);
                    //var parameterList = new List<FunctionDefinition.Argument>();
                    //var newType = mainProgram.DefineNestedType(stmt.ChildNodes[0].Token.ValueString);

                    //var currParam = stmt.ChildNodes[0].ChildNodes[2].ChildNodes[0];
                    //while (true)
                    //{
                    //    var parameterType = TypeOfExpr(currParam.ChildNodes[0].ChildNodes[1].ChildNodes[0], symbolTable);
                    //    var paramIdentifier = currParam.ChildNodes[0].ChildNodes[0];
                    //    while (true)
                    //    {
                    //        var parameterName = paramIdentifier.ChildNodes[0].Token.ValueString;
                    //        parameterList.Add(new FunctionDefinition.Argument() { argName = parameterName, argType = parameterType });
                    //        if (paramIdentifier.ChildNodes.Count == 1)
                    //            break;
                    //        paramIdentifier = paramIdentifier.ChildNodes[1];
                    //    }
                    //    if (currParam.ChildNodes.Count == 1)
                    //        break;
                    //    currParam = currParam.ChildNodes[1];
                    //}

                    /*ParseTreeNode field = stmt.ChildNodes[1].ChildNodes[0].ChildNodes[0];

                    while (true)
                    {
                        if (field.ChildNodes.Count > 1)
                        {
                            field = field.ChildNodes[1];
                        }
                        else
                            break;
                    }*/
                }
            }
            return stmt;
        }

        private void GenStmt(ParseTreeNode stmt, ILGenerator il, SymbolTable symbolTable, Label? exitScope = null)
        {
            if (stmt.Term.Name == "program")
            {
                if (stmt.ChildNodes.Count > 0)
                {
                    this.GenStmt(stmt.ChildNodes[0].ChildNodes[0], il, symbolTable);
                    this.GenStmt(stmt.ChildNodes[1], il, symbolTable);
                }
            }
            else if (stmt.Term.Name == "variableDeclaration")
            {
                Type localType;
                // declare a local
                if (stmt.ChildNodes[2].Term.Name == "typeSpecifier")
                {
                    localType = this.TypeOfTypeDeclaration(stmt.ChildNodes[2].ChildNodes[0]);
                }
                else
                {
                    localType = TypeOfExpr(stmt.ChildNodes[2].ChildNodes[1], symbolTable);
                }
                Action<string> generateAssign = null;
                ParseTreeNode assign = stmt.ChildNodes.Where(x => x.Term.Name == "setEqual").SingleOrDefault();
                // set the initial value
                if (assign != null)
                {
                    generateAssign = new Action<string>(name =>
                    {
                        this.GenExpr(assign.ChildNodes[1], symbolTable.locals[name].LocalType, il, symbolTable);
                        symbolTable.Store(name, TypeOfExpr(assign.ChildNodes[1], symbolTable), il);
                    });
                }
                var variableIden = stmt.ChildNodes[1];
                while (true)
                {
                    string name = variableIden.ChildNodes[0].Token.ValueString;
                    symbolTable.AddLocal(name, il.DeclareLocal(localType));
                    if (generateAssign != null)
                        generateAssign(name);

                    if (variableIden.ChildNodes.Count < 2)
                        break;
                    variableIden = variableIden.ChildNodes[1];
                }
            }
            else if (stmt.Term.Name == "io")
            {
                if (stmt.ChildNodes[0].Token.ValueString == "put")
                {
                    //the first argument is always there, until we can build a proper AST this'll have to do
                    ParseTreeNode argItem = stmt.ChildNodes[1];
                    this.GenExpr(argItem.ChildNodes[0], typeof(string), il, symbolTable);
                    il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("Write", new System.Type[] { typeof(string) }));
                    argItem = stmt.ChildNodes[2];
                    while (true)
                    {
                        if (argItem.ChildNodes.Count == 0)
                            break;
                        this.GenExpr(argItem.ChildNodes[0].ChildNodes[0], typeof(string), il, symbolTable);
                        il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("Write", new System.Type[] { typeof(string) }));
                        argItem = argItem.ChildNodes[1];
                    }
                    if (stmt.ChildNodes[3].ChildNodes.Count == 0)//put a newline character if there is no ...
                        il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("WriteLine", new System.Type[] { }));
                }
                else if (stmt.ChildNodes[0].Token.ValueString == "get")
                {
                    foreach (var argument in stmt.ChildNodes[1].ChildNodes)
                    {
                        //switch(symbolTable.TypeOfVar(
                        il.Emit(OpCodes.Call, typeof(System.Console).GetMethod("ReadLine", new System.Type[] { }));
                        symbolTable.Store(argument.Token.ValueString, typeof(string), il);
                    }
                }
            }
            else if (stmt.Term.Name == "assignment")
            {

                if (stmt.ChildNodes[0].Term.Name == "functionCall")//if we see this as a function call, we know that's not true, and it's actually an array (which is kinda the same thing in turing)
                {
                    string arrayName = stmt.ChildNodes[0].ChildNodes[0].Token.ValueString;
                    if (symbolTable.TypeOfVar(arrayName).IsArray)
                    {
                        symbolTable.PushVar(arrayName, il);
                        if (stmt.ChildNodes[0].ChildNodes[1].ChildNodes.Count > 1)
                            throw new NotImplementedException("Multi-Dimensional arrays are not yet supported");

                        this.GenExpr(stmt.ChildNodes[0].ChildNodes[1].ChildNodes[0], typeof(int), il, symbolTable);
                        this.GenExpr(stmt.ChildNodes[1].ChildNodes[1], TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), il, symbolTable);

                        il.Emit(OpCodes.Stelem, symbolTable.TypeOfVar(arrayName).GetElementType());
                    }
                    else
                        throw new NotSupportedException(String.Format("Non-array identifier used like an array: {0}", arrayName));
                }
                else
                {
                    this.GenExpr(stmt.ChildNodes[1].ChildNodes[1], TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), il, symbolTable);
                    string ident = stmt.ChildNodes[0].Token.ValueString;
                    symbolTable.Store(ident, TypeOfExpr(stmt.ChildNodes[1].ChildNodes[1], symbolTable), il);
                }
            }
            else if (stmt.Term.Name == "functionDefinition")
            {
                string functionName = stmt.ChildNodes[0].ChildNodes[1].Token.ValueString;
                
                SymbolTable localSymbols = new SymbolTable(symbolTable);
                foreach (var parameter in symbolTable.functionTable[functionName].arguments)
                {
                    localSymbols.AddParameter(parameter.argName, parameter.argType);
                }

                var ilMeth = symbolTable.functionTable[functionName].GetILGenerator();
                GenStmt(stmt.ChildNodes[1], ilMeth, localSymbols);
                ilMeth.Emit(OpCodes.Ret);
            }
            else if (stmt.Term.Name == "result")
            {
                GenExpr(stmt.ChildNodes[1], TypeOfExpr(stmt.ChildNodes[1], symbolTable), il, symbolTable);
                var result = il.DeclareLocal(TypeOfExpr(stmt.ChildNodes[1], symbolTable));
                il.Emit(OpCodes.Stloc, result);
                il.Emit(OpCodes.Ldloc, result);
                il.Emit(OpCodes.Ret, result);
            }
            else if (stmt.Term.Name == "functionCall" | stmt.Term.Name == "memberCall")
            {
                GenExpr(stmt, null, il, symbolTable);
            }
            else if (stmt.Term.Name == "ifBlock")
            {
                Label ifTrue = il.DefineLabel();
                Label ifFalse = il.DefineLabel();
                Label endLabel = il.DefineLabel();

                GenExpr(stmt.ChildNodes[0], typeof(bool), il, symbolTable);//expression to check if true
                il.Emit(OpCodes.Brtrue, ifTrue);//if true then jump to true block
                il.Emit(OpCodes.Br, ifFalse);//otherwise jump to false block

                il.MarkLabel(ifTrue);//true block
                GenStmt(stmt.ChildNodes[1], il, symbolTable);
                il.Emit(OpCodes.Br, endLabel);//jump to after false block

                il.MarkLabel(ifFalse);//false block
                if (stmt.ChildNodes[2].ChildNodes.Count > 0)//then there's an else-if, this takes place in the else section
                {
                    ParseTreeNode elseBlockStmt = stmt.ChildNodes[2];//Turn the elsif to an inner if statement
                    elseBlockStmt.ChildNodes.Add(stmt.ChildNodes[3]);//Move the optional else statement to the inner if statement
                    elseBlockStmt.Term.Name = "ifBlock";

                    GenStmt(elseBlockStmt, il, symbolTable);
                }
                else if (stmt.ChildNodes[3].ChildNodes.Count > 0)
                    GenStmt(stmt.ChildNodes[3].ChildNodes[0], il, symbolTable);//generate expresson for false section, otherwise the label will be at the same spot as the end

                il.MarkLabel(endLabel);//the end of the if statement
            }
            else if (stmt.Term.Name == "loop")
            {
                Label beginLoop = il.DefineLabel();
                Label endLoop = il.DefineLabel();
                il.MarkLabel(beginLoop);
                GenStmt(stmt.ChildNodes[0], il, symbolTable, endLoop);
                il.Emit(OpCodes.Br, beginLoop);
                il.MarkLabel(endLoop);
            }
            else if (stmt.Term.Name == "forLoop")
            {
                il.BeginScope();

                Label beginLoop = il.DefineLabel();
                Label endLoop = il.DefineLabel();
                LocalBuilder i = il.DeclareLocal(typeof(int));
                string identName = stmt.ChildNodes[1].Token.ValueString;
                symbolTable.AddLocal(identName, i);
                symbolTable.AddLocal("___endLoop", il.DeclareLocal(typeof(int)));
                if (stmt.ChildNodes[2].ChildNodes.Count == 1)//then an identifier is used as a range, or char. We just fail for now
                    throw new NotImplementedException();
                else
                {
                    GenExpr(stmt.ChildNodes[2].ChildNodes[0], typeof(int), il, symbolTable);
                    symbolTable.Store(identName, typeof(int), il);
                    GenExpr(stmt.ChildNodes[2].ChildNodes[1], typeof(int), il, symbolTable);
                    symbolTable.Store("___endLoop", typeof(int), il);
                }
                il.MarkLabel(beginLoop);
                GenStmt(stmt.ChildNodes[4], il, symbolTable, endLoop);
                symbolTable.PushVar(identName, il);
                il.Emit(OpCodes.Ldc_I4_1);
                if (stmt.ChildNodes[3].ChildNodes.Count > 0)//then there is a decreasing statement, so do decreasing
                    il.Emit(OpCodes.Sub);
                else
                    il.Emit(OpCodes.Add);
                il.Emit(OpCodes.Dup);
                symbolTable.Store(identName, typeof(int), il);
                symbolTable.PushVar("___endLoop", il);

                if (stmt.ChildNodes[3].ChildNodes.Count > 0)//then there is a decreasing statement, so do decreasing
                    il.Emit(OpCodes.Bge, beginLoop);
                else
                    il.Emit(OpCodes.Ble, beginLoop);
                il.MarkLabel(endLoop);
                symbolTable.RemoveLocal(identName);
                symbolTable.RemoveLocal("___endLoop");

                il.EndScope();
            }
            else
            {
                throw new System.Exception("don't know how to gen a " + stmt.Term.Name);
            }
        }

        private void GenExpr(ParseTreeNode expr, System.Type expectedType, ILGenerator il, SymbolTable symbolTable)
        {
            Type deliveredType;
            if (expr.Term.Name == "stringLiteral")
            {
                deliveredType = typeof(string);
                il.Emit(OpCodes.Ldstr, expr.Token.ValueString);
            }
            else if (expr.Term.Name == "number")
            {
                if (expr.Token.Value is int)
                {
                    deliveredType = typeof(int);
                    il.Emit(OpCodes.Ldc_I4, (int)expr.Token.Value);
                }
                else
                {
                    deliveredType = typeof(float);
                    il.Emit(OpCodes.Ldc_R4, float.Parse(expr.Token.ValueString));
                }
            }
            else if (expr.Term.Name == "binExpr")
            {
                Type innerExpectedType = TypeOfAny(symbolTable, expr.ChildNodes[0], expr.ChildNodes[2]);
                if (new string[] { "=", ">", "<", ">=", "<=", "!=", "~=", "not=", "and", "or", "xor" }.Contains(expr.ChildNodes[1].Term.Name))
                {
                    deliveredType = typeof(bool);
                }
                else
                {
                    deliveredType = innerExpectedType;
                }
                GenExpr(expr.ChildNodes[0], innerExpectedType, il, symbolTable);
                GenExpr(expr.ChildNodes[2], innerExpectedType, il, symbolTable);
                if (deliveredType == typeof(bool))
                {
                    switch (expr.ChildNodes[1].Term.Name)
                    {
                        case "=":
                            il.Emit(OpCodes.Ceq);
                            break;
                        case "<":
                            il.Emit(OpCodes.Clt);
                            break;
                        case ">":
                            il.Emit(OpCodes.Cgt);
                            break;
                        case "<=":
                            il.Emit(OpCodes.Cgt);
                            il.Emit(OpCodes.Not);
                            il.Emit(OpCodes.Ldc_I4_1);
                            il.Emit(OpCodes.And);
                            break;
                        case ">=":
                            il.Emit(OpCodes.Clt);
                            il.Emit(OpCodes.Not);
                            il.Emit(OpCodes.Ldc_I4_1);
                            il.Emit(OpCodes.And);
                            break;
                        default:
                            throw new Exception("Unrecognized operator " + expr.ChildNodes[1].Term.Name);
                    }
                }
                else if (deliveredType == typeof(string))
                {
                    switch (expr.ChildNodes[1].Term.Name)
                    {
                        case "+":
                            il.Emit(OpCodes.Call, typeof(System.String).GetMethod("Concat", new System.Type[] { typeof(string), typeof(string) }));
                            break;
                        default:
                            throw new Exception("Unrecognized operator " + expr.ChildNodes[1].Term.Name);
                    }
                }
                else
                {
                    switch (expr.ChildNodes[1].Term.Name)
                    {
                        case "+":
                            il.Emit(OpCodes.Add);
                            break;
                        case "*":
                            il.Emit(OpCodes.Mul);
                            break;
                        case "-":
                            il.Emit(OpCodes.Sub);
                            break;
                        case "/":
                            il.Emit(OpCodes.Div);
                            break;
                        case "div":
                            il.Emit(OpCodes.Div);
                            expectedType = typeof(int);
                            break;
                        case "mod":
                            il.Emit(OpCodes.Rem);
                            break;
                        default:
                            throw new Exception("Unrecognized operator " + expr.ChildNodes[1].Term.Name);
                    }
                }
            }
            else if (expr.Term.Name == "identifier")
            {
                string ident = expr.Token.ValueString;
                symbolTable.PushVar(ident, il);
                deliveredType = TypeOfExpr(expr, symbolTable);
            }
            else if (expr.Term.Name == "functionCall"|expr.Term.Name=="memberCall")
            {
                deliveredType = TypeOfExpr(expr, symbolTable);

                string funcName = GetIdentifier(expr);
                if (!symbolTable.functionTable.ContainsKey(funcName))
                {
                    if (symbolTable.HasVar(funcName) && symbolTable.TypeOfVar(funcName).IsArray)
                    {
                        //this is an array, return the appropriate value
                        symbolTable.PushVar(funcName, il);
                        if (expr.ChildNodes[1].ChildNodes.Count > 1)
                            throw new NotImplementedException("Multi-Dimensional arrays are not yet supported");

                        this.GenExpr(expr.ChildNodes[1].ChildNodes[0], typeof(int), il, symbolTable);

                        il.Emit(OpCodes.Stelem, symbolTable.TypeOfVar(funcName).GetElementType());
                    }
                    else
                        throw new System.Exception("undeclared function or procedure '" + funcName + "'");
                }
                else
                {
                    var parameters = symbolTable.functionTable[funcName].methodDefinition.GetParameters();
                    int currentArgument = 0;
                    foreach (var arg in GetArgs(expr))//expr.ChildNodes[1].ChildNodes)
                    {
                        this.GenExpr(arg, parameters[currentArgument].ParameterType, il, symbolTable);
                        currentArgument++;
                    }
                    il.Emit(OpCodes.Call, symbolTable.functionTable[funcName].methodDefinition);
                }
            }
            else if (expr.Term.Name == "initExpr")
            {
                deliveredType = TypeOfAny(symbolTable, expr.ChildNodes[0].ChildNodes.ToArray());

                int arraySize = expr.ChildNodes[0].ChildNodes.Count;
                //LocalBuilder paramValues = il.DeclareLocal(deliveredType.MakeArrayType());
                //paramValues.SetLocalSymInfo("parameters");
                il.Emit(OpCodes.Ldc_I4_S, arraySize);
                il.Emit(OpCodes.Newarr, deliveredType);
                //il.Emit(OpCodes.Stloc, paramValues);
                for (int i = 0; i < expr.ChildNodes[0].ChildNodes.Count; i++)
                {
                    il.Emit(OpCodes.Dup);
                    il.Emit(OpCodes.Ldc_I4, i);
                    GenExpr(expr.ChildNodes[0].ChildNodes[i], deliveredType, il, symbolTable);
                    il.Emit(OpCodes.Stelem, deliveredType);
                }
                deliveredType = deliveredType.MakeArrayType();
            }
            else if (expr.Term.Name == "skip")
            {
                deliveredType = typeof(string);
                il.Emit(OpCodes.Ldstr, Environment.NewLine);
            }
            else
            {
                throw new System.Exception("don't know how to generate " + expr.Term.Name);
            }
            if (deliveredType != expectedType)
            {
                if (deliveredType == typeof(int) &&
                    expectedType == typeof(string))
                {
                    il.Emit(OpCodes.Box, typeof(int));
                    il.Emit(OpCodes.Callvirt, typeof(object).GetMethod("ToString"));
                }
                else if (deliveredType == typeof(float) && expectedType == typeof(string))
                {
                    il.Emit(OpCodes.Box, typeof(float));
                    il.Emit(OpCodes.Callvirt, typeof(object).GetMethod("ToString"));
                }
                else if (expectedType == null)//if the expected type is null then it doesn't matter what you give it
                {
                    
                }
                else
                {
                    throw new System.Exception("can't coerce a " + deliveredType.Name + " to a " + expectedType.Name);
                }
            }
        }

        static public Type TypeOfExpr(ParseTreeNode expr, SymbolTable symbolTable)
        ]]></source>
</chunk>
<method name="TypeOfExpr" namespace="IronTuring" type="IronTuring.CodeGen" typeName="CodeGen" token="6000016" module="IronTuring.exe"><hits><hit index="0" value="1"/>
<hit index="1" value="1"/>
<hit index="260" value="1"/>
</hits>
<coverage domain="usercodeundertest" unit="block" covered="1" total="90" coveredRatio="0.011111111111111112"/>
</method>
<chunk hits="1" offset="0000" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="1" offset="0001" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "stringLiteral")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="001d" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="001e" domain="usercodeundertest"><source><![CDATA[return typeof(string);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            ]]></source>
</chunk>
<chunk hits="0" offset="002e" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "number")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="004a" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="004b" domain="usercodeundertest"><source><![CDATA[if (expr.Token.Value is int)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0065" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0066" domain="usercodeundertest"><source><![CDATA[return typeof(int);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                }
                else
                ]]></source>
</chunk>
<chunk hits="0" offset="0076" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0077" domain="usercodeundertest"><source><![CDATA[return typeof(float);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                }
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="0087" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "binExpr")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00a3" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //Type type1 = TypeOfExpr(expr.ChildNodes[0], symbolTable);
                //Type type2 = TypeOfExpr(expr.ChildNodes[2], symbolTable);
                ]]></source>
</chunk>
<chunk hits="0" offset="00a4" domain="usercodeundertest"><source><![CDATA[return TypeOfAny(symbolTable, expr.ChildNodes[0], expr.ChildNodes[2]);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                //if (type1 == typeof(float) || type2 == typeof(float))
                //    return typeof(float);
                //return typeof(int);
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="00da" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "identifier")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="00f6" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="00f7" domain="usercodeundertest"><source><![CDATA[string ident = expr.Token.ValueString;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0103" domain="usercodeundertest"><source><![CDATA[return symbolTable.TypeOfVar(ident);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="0110" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "functionCall")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="012f" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0130" domain="usercodeundertest"><source><![CDATA[string funcName = expr.ChildNodes[0].Token.ValueString;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0147" domain="usercodeundertest"><source><![CDATA[if (!symbolTable.functionTable.ContainsKey(funcName))]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="0157" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    //it might be an array, so we should check for that
                    ]]></source>
</chunk>
<chunk hits="0" offset="0158" domain="usercodeundertest"><source><![CDATA[if (symbolTable.HasVar(funcName) && symbolTable.TypeOfVar(funcName).IsArray)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    ]]></source>
</chunk>
<chunk hits="0" offset="0177" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                        //it is an array, so just return the appropriate type for the array
                        ]]></source>
</chunk>
<chunk hits="0" offset="0178" domain="usercodeundertest"><source><![CDATA[return symbolTable.TypeOfVar(funcName).GetElementType();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    }
                    else//nope, throw an error
                        ]]></source>
</chunk>
<chunk hits="0" offset="018a" domain="usercodeundertest"><source><![CDATA[throw new System.Exception("undeclared function or procedure '" + funcName + "'");]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                }
                ]]></source>
</chunk>
<chunk hits="0" offset="01a0" domain="usercodeundertest"><source><![CDATA[return symbolTable.functionTable[funcName].methodDefinition.ReturnType;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="01bc" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "memberCall")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="01d8" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="01d9" domain="usercodeundertest"><source><![CDATA[return symbolTable.functionTable[GetIdentifier(expr)].methodDefinition.ReturnType;]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="01fa" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "varType")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="0219" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="021a" domain="usercodeundertest"><source><![CDATA[switch (expr.ChildNodes[0].Token.ValueString)]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                {
                    case "int":
                        ]]></source>
</chunk>
<chunk hits="0" offset="0254" domain="usercodeundertest"><source><![CDATA[return typeof(int);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    case "real":
                        ]]></source>
</chunk>
<chunk hits="0" offset="0264" domain="usercodeundertest"><source><![CDATA[return typeof(float);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                    default:
                        ]]></source>
</chunk>
<chunk hits="0" offset="0274" domain="usercodeundertest"><source><![CDATA[throw new Exception("Did not recognize type: " + expr.ChildNodes[0].Token.ValueString);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                }
            }
            else ]]></source>
</chunk>
<chunk hits="0" offset="029a" domain="usercodeundertest"><source><![CDATA[if (expr.Term.Name == "initExpr")]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            ]]></source>
</chunk>
<chunk hits="0" offset="02b6" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="02b7" domain="usercodeundertest"><source><![CDATA[return TypeOfAny(symbolTable, expr.ChildNodes[0].ChildNodes.ToArray()).MakeArrayType();]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
            else
            ]]></source>
</chunk>
<chunk hits="0" offset="02db" domain="usercodeundertest"><source><![CDATA[{]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
                ]]></source>
</chunk>
<chunk hits="0" offset="02dc" domain="usercodeundertest"><source><![CDATA[throw new System.Exception("don't know how to calculate the type of " + expr.Term.Name);]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
            }
        ]]></source>
</chunk>
<chunk hits="0" offset="02f7" domain="usercodeundertest"><source><![CDATA[}]]></source>
</chunk>
<chunk hits="-1" domain="unknown"><source><![CDATA[
        /// <summary>
        /// This method takes in types and selects the best type to represent the resulting type (for instance int and real would return real)
        /// </summary>
        /// <param name="inputTypes">The types to select from</param>
        /// <returns>The best type to represent values from all the input types</returns>
        static Type TypeOfAny(SymbolTable symbolTable, params ParseTreeNode[] inputExprs)
        {
            Type bestType=null;
            foreach (var inputExpr in inputExprs)
            {
                Type inputType = TypeOfExpr(inputExpr, symbolTable);
                if (bestType == null)
                    bestType = inputType;
                else if (bestType == inputType)
                {
                }
                else if (bestType == typeof(int) && inputType == typeof(float))
                {
                    bestType = typeof(float);
                }
                else
                {
                    throw new InvalidCastException(String.Format("Cannot convert type {0} to type {1}", inputType, bestType));
                }
            }
            return bestType;
        }
        private Type TypeOfTypeDeclaration(ParseTreeNode expr)
        {
            switch (expr.ChildNodes[0].Token.ValueString)
            {
                case "array":
                    return TypeOfTypeDeclaration(expr.ChildNodes[3]).MakeArrayType();
                    throw new NotImplementedException();
                case "int":
                    return typeof(int);
                case "string":
                    return typeof(string);
                case "real":
                    return typeof(float);
                default:
                    throw new System.Exception("don't know how to calculate the type of " + expr.ToString());
            }
        }
    }
}]]></source>
</chunk>
</document>
<document src="(no sources available for some parts of IronTuring.Tests, Irony.Explorables, Irony)" missing="true"><method name="Constructor" type="IronTuring.CodeGenOldTest" token="6000001" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="1" total="2" coveredRatio="0.5"/>
</method>
<method name="Constructor" type="IronTuring.CodeGenTest" token="6000003" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="1" total="2" coveredRatio="0.5"/>
</method>
<method name="TypeOfExpr" type="IronTuring.CodeGenTest" token="6000004" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="1" total="2" coveredRatio="0.5"/>
</method>
<method name="Create" type="Irony.Parsing.RegexLiteralFactory" token="6000026" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.RegexLiteral" token="6000264" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.RegexLiteral+RegexSwitchTable" token="600026b" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.Terminal" token="6000103" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.Terminal" token="6000106" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="6" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.BnfTerm" token="600002a" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.BnfTerm" token="600002d" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name="set_OutputTerminal" type="Irony.Parsing.Terminal" token="6000108" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="set_AstConfig" type="Irony.Parsing.BnfTerm" token="600003c" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.RegexLiteral" token="6000265" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.Terminal" token="6000109" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.BnfTerm" token="600002e" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.TokenFactory" token="6000004" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.Token" token="6000196" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name="SetTerminal" type="Irony.Parsing.Token" token="6000197" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name="set_Terminal" type="Irony.Parsing.Token" token="6000194" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="get_Terminal" type="Irony.Parsing.Token" token="6000193" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.ParseTreeNodeFactory" token="6000002" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.ParseTreeNode" token="60001a8" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="7" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.ParseTreeNode" token="60001a7" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.ParseTreeNodeList" token="60001b1" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="set_ChildNodes" type="Irony.Parsing.ParseTreeNode" token="60001a6" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="get_Length" type="Irony.Parsing.Token" token="600019b" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.SourceSpan" token="6000057" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="IsError" type="Irony.Parsing.Token" token="600019a" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="get_Category" type="Irony.Parsing.Token" token="6000199" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.WikiTagTerminalFactory" token="6000022" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.WikiTagTerminal" token="600024a" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.WikiTerminalBase" token="6000124" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.WikiTerminalBase" token="6000126" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="18" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.WikiBlockTerminalFactory" token="600002c" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.WikiBlockTerminal" token="60002ea" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.KeyTermFactory" token="600002e" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.KeyTerm" token="6000315" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name="set_Text" type="Irony.Parsing.KeyTerm" token="6000317" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.KeyTerm" token="6000318" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="25" coveredRatio="0"/>
</method>
<method name="IsSet" type="Irony.Parsing.ParsingEnumExtensions" token="60002ec" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name="get_Text" type="Irony.Parsing.KeyTerm" token="6000316" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="1" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.TokenEditorInfo" token="600035d" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Create" type="Irony.Parsing.StringLiteralFactory" token="6000030" module="&lt;In Memory Module&gt;"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.StringLiteral" token="6000324" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.StringLiteral" token="6000321" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.StringLiteral" token="6000320" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.StringLiteral+StringSubTypeList" token="6000336" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.CompoundTerminalBase" token="60001f1" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.CompoundTerminalBase" token="60001f2" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="9" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.EscapeTable" token="60001f0" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.CompoundTerminalBase+ScanFlagTable" token="6000200" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.CompoundTerminalBase+TypeCodeTable" token="6000201" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.StringList" token="6000188" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="SetFlag" type="Irony.Parsing.BnfTerm" token="6000033" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="SetFlag" type="Irony.Parsing.BnfTerm" token="6000034" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="3" coveredRatio="0"/>
</method>
<method name="GetDefaultEscapes" type="Irony.Parsing.CompoundTerminalBase" token="60001ff" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="14" coveredRatio="0"/>
</method>
<method name="Add" type="Irony.Parsing.StringLiteral+StringSubTypeList" token="6000335" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Parsing.StringLiteral+StringSubType" token="6000333" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="get_AstConfig" type="Irony.Parsing.BnfTerm" token="600003b" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="4" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.Ast.AstNodeConfig" token="60002fc" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.StringLiteral" token="6000328" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="59" coveredRatio="0"/>
</method>
<method name="Init" type="Irony.Parsing.CompoundTerminalBase" token="60001f5" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="22" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.CharHashSet" token="600017f" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
<method name=".ctor" type="Irony.StringSet" token="6000183" module="Irony.dll"><hits/>
<coverage domain="userortestcode" unit="block" covered="0" total="2" coveredRatio="0"/>
</method>
</document>
</documents>
